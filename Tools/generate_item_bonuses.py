import os
import concurrent.futures

from dm_tools import (
    get_latest_game_version,
    DB2,
    Schema,
    ITEMBONUS_DB2,
    ItemBonus,
    ITEMBONUSLIST_DB2,
    ItemBonusList,
    ITEMBONUSLISTGROUP_DB2,
    ItemBonusListGroup,
    ITEMBONUSLISTGROUPENTRY_DB2,
    ItemBonusListGroupEntry,
)

from dm_logging import get_logger

logger = get_logger()

MAX_THREADS = os.cpu_count()
UPDATE_ALL = False

parent_directory = os.path.dirname(os.getcwd())
ADDON_DIR = os.path.join(parent_directory, "Datamine_Static")
OUTPUT_DIR = os.path.join(ADDON_DIR, "Generated")

FILE_NAME = os.path.basename(__file__)

WOW_DIR = "F:/Games/World of Warcraft"
FLAVOR = "wow"

TOC_FILE_LIST_LINE_NO = 17

os.makedirs(OUTPUT_DIR, exist_ok=True)

LUA_PREAMBLE = """-- This file was generated by {file}
-- Version: {version}

local _, Datamine_Static = ...;
"""

LUA_FORMAT = (
    LUA_PREAMBLE
    + """
Datamine_Static.{tableName} = {{
{data}
}};
"""
)


def tabs(depth: int):
    return "\t" * depth


_TABS = {0: "", 1: tabs(1), 2: tabs(2), 3: tabs(3)}


def add_files_to_toc():
    toc_path = os.path.join(ADDON_DIR, "Datamine_Static.toc")
    with open(toc_path, "r") as f:
        toc_lines = f.readlines()

    with open(toc_path, "w") as f:
        f.truncate()
        f.writelines(toc_lines[:TOC_FILE_LIST_LINE_NO])

        for file in os.listdir(OUTPUT_DIR):
            if file.endswith(".lua"):
                f.write(f"Generated/{file}\n")
            elif os.path.isdir(os.path.join(OUTPUT_DIR, file)):
                for nested_file in os.listdir(os.path.join(OUTPUT_DIR, file)):
                    if nested_file.endswith(".lua"):
                        f.write(f"Generated/{file}/{nested_file}\n")
            else:
                os.remove(os.path.join(OUTPUT_DIR, file))


def lua_format(tableName: str, data: str):
    version = get_latest_game_version()
    return LUA_FORMAT.format(
        file=FILE_NAME, version=version, tableName=tableName, data=data
    )


def format_things(things: list[Schema]):
    all_things = ""

    first_line = True
    for thing in things:
        thing_tbl = f"{_TABS[1]}[{thing.ID}] = {thing.to_lua_table(tabOffset=1)}"

        if not first_line:
            thing_tbl = "\n" + thing_tbl
        else:
            first_line = False

        all_things += thing_tbl

    return all_things


def write(tableName: str, db2: DB2, format_func):
    things = [thing for thing in db2.read()]
    data = format_func(things)

    output_file = os.path.join(OUTPUT_DIR, f"{tableName}.lua")
    with open(output_file, "w") as f:
        f.write(lua_format(tableName=tableName, data=data))


def get_indices_for_listID(listID: int):
    group_entry_ids = []
    group_ids = []

    for entry in ITEMBONUSLISTGROUPENTRY_DB2.read():
        if entry.ItemBonusListID != listID:
            continue

        group_entry_ids.append(entry.ID)
        group_ids.append(entry.ItemBonusListGroupID)

    group_entry_ids = [*set(group_entry_ids)]
    group_ids = [*set(group_ids)]

    return group_ids, group_entry_ids


def generate_indices():
    tbl = "{"

    listIDToGroupEntries = "\n" + _TABS[1] + "ListIDToGroupEntries = {"
    listIDToGroupIDs = "\n" + _TABS[1] + "ListIDToGroupIDs = {"

    for bonusList in ITEMBONUSLIST_DB2.read():
        group_ids, group_entry_ids = get_indices_for_listID(bonusList.ID)

        offset = 2
        listIDToGroupEntries += "\n" + _TABS[offset] + f"[{bonusList.ID}] = {{"
        listIDToGroupIDs += "\n" + _TABS[offset] + f"[{bonusList.ID}] = {{"

        for entryID in group_entry_ids:
            listIDToGroupEntries += "\n" + _TABS[offset + 1] + entryID + ","

        for groupID in group_ids:
            listIDToGroupIDs += "\n" + _TABS[offset + 1] + groupID + ","

        listIDToGroupEntries += "\n" + _TABS[offset] + "};"
        listIDToGroupIDs += "\n" + _TABS[offset] + "};"

    listIDToGroupEntries += "\n" + _TABS[1] + "};"
    listIDToGroupIDs += "\n" + _TABS[1] + "};"

    tbl += listIDToGroupEntries
    tbl += listIDToGroupIDs
    tbl += "\n" + "};"

    output_file = os.path.join(OUTPUT_DIR, "Indices", "ItemBonus_Indices.lua")
    with open(output_file, "w") as f:
        f.write(lua_format(tableName="ItemBonus_Indices", data=tbl))


with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_THREADS) as executor:
    futures = [
        executor.submit(write, "ItemBonus", ITEMBONUS_DB2, format_things),
        executor.submit(write, "ItemBonusList", ITEMBONUSLIST_DB2, format_things),
        executor.submit(
            write, "ItemBonusListGroup", ITEMBONUSLISTGROUP_DB2, format_things
        ),
        executor.submit(
            write,
            "ItemBonusListGroupEntry",
            ITEMBONUSLISTGROUPENTRY_DB2,
            format_things,
        ),
    ]

    for task in concurrent.futures.as_completed(futures):
        if task.exception() is not None:
            logger.exception(
                f"Encountered an error handling task: {task.exception().__context__}"
            )

    concurrent.futures.wait(futures)

generate_indices()
add_files_to_toc()
